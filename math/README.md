# 알고리즘 노트(파이썬)


### 약수 1 (기초 알고리즘)
> 하나의 자연수를 나누어 떨어지게 하는 수이다.<br>
> 나누어 떨어진다는 뜻은 몫만 존재하며 나머지가 없다는 의미이다.

> 예를 들어 10이라는 자연수를 2로 나눈다고 생각해보자. <br>

> ex) 10 / 2 = 5 ... 0 <br>
> 10을 2로 나누면 몫은 5, 나머지는 0이다.<br>
> 나머지가 0이란 뜻은 나머지가 없다는 뜻과 동일하므로 2는 10의 약수이다.
  
> 이를 코드로 표현하면 10%2 == 0로 표현할 수 있다. <br>
> 즉 N % i == 0이면 i는 N의 약수이다. 

```python

n = int(input())
arr = []

for i in range (1,n+1) :
  if n % i == 0: 
      arr.append(i) 

print(arr) # 약수 리스트
print(len(arr)) # 약수의 갯수 
```


### 약수 2
> a * b = N이면 a와 b는 N(자연수)의 약수이다. <br>

> 10 / 2 = 5 ...0 이므로 몫은 5, 나머지는 0, 약수는 2인 것을 증명했다. <br>
> 여기에서 약수인 2와 몫인 5를 곱하면? <br>
> 2 * 5 == 10이 나오는 현상을 발견할 수 있다. <br>
> 여기에서 알 수 있는 것은 두 가지이다. <br>

>1. 약수(2)와 몫(5)를 곱하면 소속된 자연수(10)가 된다. <br> 
>2. 「a * b = N이면 a,b는 약수」이다 공식이 적용되므로 2와 5 둘 다 약수인 것을 알 수 있다.<br> 

> 즉 10/2 = 5 ...0 에서 2는 물론, 몫인 5도 10의 약수가 된다.
ex> N % i == 0 이면 i뿐만 아니라 N//i도 약수이다.

```py
n = int(input())
arr = []

for i in range(1,n+1):
  if n % i == 0
    arr.append(i)
    arr.append(n//i)
```

>하지만 위의 코드는 중복된 수가 존재한다. <br>
>1,10  2,5  5,2  10,2 로 약수가 두 번씩 들어가기 때문이다.


### 약수 3 (성능 개선 알고리즘)
>a * b  = N이면 두 약수 a,b는 대칭한다. <br>
>a * a  = N이면 a는 약수이자 제곱근이다. 즉 제곱근도 약수이다.<br>

>10의 약수는 [1,2,5,10] 이며 1*10, 2*5는 10인 것을 알 수 있다. <br>
>주목할 부분은 바로 거리이다.<br>

>100의 약수로 다시 한 번 관찰해보자<br>
>[1 2 4 5 10 20 25 50 100]  <br>
>이 경우도 가장 가까운 1과 가장 먼 100이 대칭하며 그 옆에 존재하는 2,50도 대칭하는 것을 알 수 있다.<br>

>또한 중요한 포인트로 가운데에 있는 10은 대칭하는 수가 존재하지 않는다.<br>
>하지만 10을 제곱하면 100이 된다.<br>
>이렇게 같은 수를 제곱해서 N이 되면 그 같은 수가 N의 제곱근이며 약수에도 포함되는 것을 알 수 있다.<br>

> 그러므로, 어떠한 자연수 N의 약수를 구하고 싶은 경우,<br>
> 우선 자연수 N의 제곱근까지만 반복한다.
> 약수 2 에서 증명한 것처럼 나머지 약수(20,25,50,100)는 몫을 통해 추가하면 된다.

> n -> int(n**(1/2)) <br>
> n 곱하기 1/2는 제곱근은 의미한다. n ** (1/2) 는 n의 2분의 1 제곱이라는 뜻이다. <br> 

> 100의 제곱근은 10이므로 정수이지만 10의 제곱근은 3.xxxx이므로 int()를 사용하여 정수로 변환한다.<br>
> 1번, 2번 반복은 해도 2.8번, 3.xxx번 반복한다는 건 이상하죠? 그러니까 정수로 변환이 필수이다. <br>


```py
n = int(input())
arr = []

for i in range(1,int(n**(1/2))+1):
  if n % i == 0      # n의 제곱근까지의 약수는 반드시 추가된다.
    arr.append(i)
    if i * i != n    # i의 제곱이 n이 아니면, i는 n의 제곱근이 아니므로 바로 추가하고 중복을 피할 수 있다.
      arr.append(n//i)
```





### 소수 판별

```python
def is_prime_number(n):
    if n < 2:
        return False
    for i in range(2, int(n**(1/2)) + 1):
        if n % i == 0:
            return False
    return True
```

### 여러 개의 소수 판별(for-break-else)

```py
loop = int(input())
unchecked_list = list(map(int,input().split()))

prime_count = 0
for i in unchecked_list:
    if i < 2:
          continue
    for j in range(2, int(i**(1/2))+1):
        if i % j == 0:
            break
    else: 
          prime_count += 1

print(prime_count)
```


     
  
